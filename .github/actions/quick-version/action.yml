name: "Quick Version"
description: "A simple version generate that uses commit comments and settings file to compute the next version."

inputs:
  version-label:
    description: "The version label to append, e.g., 'rc' or 'beta'. If empty, no label is appended."
    required: false
    default: ""
  build-metadata:
    description: "The build metadata to append, e.g., 'sha1234567'. If empty, no build metadata is appended."
    required: false
    default: ""

outputs:
  major:
    description: "The major version number"
    value: ${{ steps.compute.outputs.major }}
  minor:
    description: "The minor version number"
    value: ${{ steps.compute.outputs.minor }}
  build:
    description: "The build version number"
    value: ${{ steps.compute.outputs.build }}
  patch:
    description: "The patch version number"
    value: ${{ steps.compute.outputs.patch }}
  version:
    description: "The full version number in the format #.#.#.#"
    value: ${{ steps.compute.outputs.version }}
  label:
    description: "The version label, e.g., rc.1+sha3efddf..."
    value: ${{ steps.compute.outputs.major }}
  infoVersion:
    description: "The informational vesion in the format #.#.#.#-LABEL, e.g., 1.2.3.4-rc.1+sha3efddf..."
    value: ${{ steps.compute.outputs.infoVersion }}

runs:
  using: "composite"
  steps: 
    - id: compute
      shell: pwsh
      run: |
        if(Test-Path "./git/shallow") {
          Write-Warning "A non-shallow checkout must be done prior to using quick-version, i.e., fetch-depth: 0"
          exit 1
        }
        
        . (Join-Path $env:GITHUB_ACTION_PATH 'action.ps1')

        # ---------------------------------------------------------------------------------------------
        # Build tag → commit map; parse all tag versions
        # ---------------------------------------------------------------------------------------------
        $tagLines = git for-each-ref refs/tags --format="%(refname:short)|%(objecttype)|%(objectname)|%(taggedobject)"
        $tagMap = @{}  # commitSha -> List[QuickVersion]
        $allVersions = New-Object 'System.Collections.Generic.List[QuickVersion]'

        foreach ($line in $tagLines) {
            if ([string]::IsNullOrWhiteSpace($line)) { continue }
            $parts = $line -split '\|', 4
            if ($parts.Count -lt 3) { continue }
            $name = $parts[0]; $otype = $parts[1]; $obj = $parts[2]; $tagged = if ($parts.Count -ge 4) { $parts[3] } else { "" }

            # Resolve commit SHA for lightweight vs annotated tags
            $commitSha = if ($otype -eq 'tag' -and -not [string]::IsNullOrWhiteSpace($tagged)) { $tagged } else { $obj }

            $ver = [QuickVersion]::Parse($name)
            if ($null -ne $ver) {
                if (-not $tagMap.ContainsKey($commitSha)) {
                    $tagMap[$commitSha] = New-Object 'System.Collections.Generic.List[QuickVersion]'
                }
                $tagMap[$commitSha].Add($ver) | Out-Null
                $allVersions.Add($ver) | Out-Null
            }
        }

        # ---------------------------------------------------------------------------------------------
        # Walk commits newest → oldest
        # Stop collecting messages at the first commit that has a Production Release tag.
        # STILL continue collecting versions (done above from tags).
        # ---------------------------------------------------------------------------------------------
        $messages = New-Object 'System.Collections.Generic.List[QuickVersionMessage]'
        $stopMessages = $false

        # Use NUL-delimited output for robust parsing
        $raw = git log --no-color --pretty=format:"%H%x00%B%x00"
        $tokens = $raw -split ([string][char]0)
        for ($i = 0; $i -lt $tokens.Length - 1; $i += 2) {
            $sha = $tokens[$i]
            $body = $tokens[$i + 1]

            # If this commit has a Production Release tag and we haven't cut off yet,
            # skip messages for this commit AND all older ones.
            if (-not $stopMessages -and $tagMap.ContainsKey($sha)) {
                if ($tagMap[$sha] | Where-Object { $_.IsProduction() }) {
                    $stopMessages = $true
                    continue  # do not process messages for this commit
                }
            }

            if (-not $stopMessages) {
                $msgs = [QuickVersionMessage]::Parse($body)
                foreach ($m in $msgs) { $messages.Add($m) | Out-Null }
            }
        }

        # ---------------------------------------------------------------------------------------------
        # Determine lastVersion (highest Production Release) and nexts
        # ---------------------------------------------------------------------------------------------
        $prodVersions = $allVersions | Where-Object { $_.IsProduction() }

        if ($prodVersions.Count -gt 0) {
            $lastVersion = $prodVersions | Sort-Object `
                @{ e = { $_.Major }; Descending = $true }, `
                @{ e = { $_.Minor }; Descending = $true }, `
                @{ e = { $_.Patch }; Descending = $true }, `
                @{ e = { $_.Build }; Descending = $true } `
                | Select-Object -First 1
        } else {
            # No production version found; treat as 0.0.0.0 baseline
            $lastVersion = [QuickVersion]::new(0,0,0,0,"",0,"")
        }

        $nextVersionMajor = [QuickVersion]::new($lastVersion.Major + 1, 0, 0, 0, "", 0, "")
        $nextVersionMinor = [QuickVersion]::new($lastVersion.Major, $lastVersion.Minor + 1, 0, 0, "", 0, "")
        $nextVersionPatch = [QuickVersion]::new($lastVersion.Major, $lastVersion.Minor, $lastVersion.Patch + 1, 0, "", 0, "")
        $nextVersionBuild = [QuickVersion]::new($lastVersion.Major, $lastVersion.Minor, $lastVersion.Patch, $lastVersion.Build + 1, "", 0, "")

        # ---------------------------------------------------------------------------------------------
        # Display (or set outputs in a composite action)
        # ---------------------------------------------------------------------------------------------
        Write-Host "Production versions found: $($prodVersions.Count)"
        Write-Host "Last production version : $($lastVersion.ToString())"
        Write-Host "Next major              : $($nextVersionMajor.ToString())"
        Write-Host "Next minor              : $($nextVersionMinor.ToString())"
        Write-Host "Next patch              : $($nextVersionPatch.ToString())"
        Write-Host "Next build              : $($nextVersionBuild.ToString())"
        Write-Host ""
        Write-Host "Conventional commit messages collected (newest → oldest, until latest prod tag): $($messages.Count)"
        $messages | ForEach-Object { Write-Host (" - {0}: {1}" -f $_.Type, $_.Message) }

        # If running inside GitHub Actions and you want outputs:
        if ($env:GITHUB_OUTPUT) {
            # Serialize complex types as JSON
            $jsonMessages = $messages | ConvertTo-Json -Depth 6
            $jsonProdVers = $prodVersions | ConvertTo-Json -Depth 6
            "lastVersion=$($lastVersion.ToString())"           >> $env:GITHUB_OUTPUT
            "nextVersionMajor=$($nextVersionMajor.ToString())" >> $env:GITHUB_OUTPUT
            "nextVersionMinor=$($nextVersionMinor.ToString())" >> $env:GITHUB_OUTPUT
            "nextVersionPatch=$($nextVersionPatch.ToString())" >> $env:GITHUB_OUTPUT
            "nextVersionBuild=$($nextVersionBuild.ToString())" >> $env:GITHUB_OUTPUT
            "messagesJson=$jsonMessages"                       >> $env:GITHUB_OUTPUT
            "productionVersionsJson=$jsonProdVers"             >> $env:GITHUB_OUTPUT
        }
