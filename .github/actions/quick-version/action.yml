name: "Quick Version"
description: "A simple version generate that uses commit comments and settings file to compute the next version."

inputs:
  version-label:
    description: "The version label to append, e.g., 'rc' or 'beta'. If empty, no label is appended."
    required: false
    default: ""
  build-metadata:
    description: "The build metadata to append, e.g., 'sha1234567'. If empty, no build metadata is appended."
    required: false
    default: ""
  include-paths:
    description: "Semicolon-separated glob/prefix patterns to INCLUDE commits by changed paths (e.g. src/;lib/). Empty = include all commits."
    required: false
    default: "src/;lib/;source/"
  exclude-paths:
    description: "Semicolon-separated glob/prefix patterns to EXCLUDE commits by changed paths (e.g. docs/;test/)."
    required: false
    default: ".github/;tests/;docs/"

outputs:
  major:
    description: "The major version number"
    value: ${{ steps.compute.outputs.major }}
  minor:
    description: "The minor version number"
    value: ${{ steps.compute.outputs.minor }}
  build:
    description: "The build version number"
    value: ${{ steps.compute.outputs.build }}
  patch:
    description: "The patch version number"
    value: ${{ steps.compute.outputs.patch }}
  version:
    description: "The full version number in the format #.#.#.#"
    value: ${{ steps.compute.outputs.version }}
  label:
    description: "The version label, e.g., rc.1+sha3efddf..."
    value: ${{ steps.compute.outputs.label }}   # <-- fixed (was major)
  infoVersion:
    description: "The informational vesion in the format #.#.#.#-LABEL, e.g., 1.2.3.4-rc.1+sha3efddf..."
    value: ${{ steps.compute.outputs.infoVersion }}

runs:
  using: "composite"
  steps: 
    - id: compute
      shell: pwsh
      run: |
        # check correct shallow file path
        if (Test-Path ".git/shallow") {
          Write-Warning "A non-shallow checkout must be done prior to using quick-version, i.e., fetch-depth: 0"
          exit 1
        }

        . (Join-Path $env:GITHUB_ACTION_PATH 'action.ps1')


        # read include/exclude patterns (semicolons separated)
        $includeRaw = $env:INPUT_INCLUDE_PATHS
        $excludeRaw = $env:INPUT_EXCLUDE_PATHS
        $includePatterns = @()
        $excludePatterns = @()
        if (-not [string]::IsNullOrWhiteSpace($includeRaw)) {
            $includePatterns = $includeRaw -split ';' | ForEach-Object { $_.Trim().TrimStart('/','\') }
        }
        if (-not [string]::IsNullOrWhiteSpace($excludeRaw)) {
            $excludePatterns = $excludeRaw -split ';' | ForEach-Object { $_.Trim().TrimStart('/','\') }
        }


        # ---------------------------------------------------------------------------------------------
        # Build tag → commit map; parse all tag versions
        # ---------------------------------------------------------------------------------------------
        $tagLines = git for-each-ref refs/tags --format="%(refname:short)|%(objecttype)|%(objectname)"
        $tagMap = @{}  # commitSha -> List[QuickVersion]
        $allVersions = New-Object 'System.Collections.Generic.List[QuickVersion]'

        foreach ($line in $tagLines) {
            if ([string]::IsNullOrWhiteSpace($line)) { continue }
            $parts = $line -split '\|', 3
            if ($parts.Count -lt 3) { continue }
            $name = $parts[0]; $otype = $parts[1]; $obj = $parts[2]

            # Resolve commit SHA for lightweight vs annotated tags (peel annotated tags)
            if ($otype -eq 'tag') {
                $commitSha = (git rev-parse "$name^{}").Trim()
            } else {
                $commitSha = $obj
            }

            $ver = [QuickVersion]::Parse($name)
            if ($null -ne $ver) {
                if (-not $tagMap.ContainsKey($commitSha)) {
                    $tagMap[$commitSha] = New-Object 'System.Collections.Generic.List[QuickVersion]'
                }
                $tagMap[$commitSha].Add($ver) | Out-Null
                $allVersions.Add($ver) | Out-Null
            }
        }

        # ---------------------------------------------------------------------------------------------
        # Walk commits newest → oldest
        # Stop collecting messages at the first commit that has a Production Release tag.
        # STILL continue collecting versions (done above from tags).
        # ---------------------------------------------------------------------------------------------
        $messages = New-Object 'System.Collections.Generic.List[QuickVersionMessage]'
        $stopMessages = $false

        # Use NUL-delimited output for robust parsing
        $raw = git log --no-color --pretty=format:"%H%x00%B%x00"
        $tokens = $raw -split ([string][char]0)
        # for ($i = 0; $i -lt $tokens.Length - 1; $i += 2) {
        #     $sha = $tokens[$i]
        #     $body = $tokens[$i + 1]

        #     # If this commit has a Production Release tag and we haven't cut off yet,
        #     # skip messages for this commit AND all older ones.
        #     if (-not $stopMessages -and $tagMap.ContainsKey($sha)) {
        #         if ($tagMap[$sha] | Where-Object { $_.IsProduction() }) {
        #             $stopMessages = $true
        #             continue  # do not process messages for this commit
        #         }
        #     }

        #     if (-not $stopMessages) {
        #         $msgs = [QuickVersionMessage]::Parse($body)
        #         foreach ($m in $msgs) { $messages.Add($m) | Out-Null }
        #     }
        # }
        for ($i = 0; $i -lt $tokens.Length - 1; $i += 2) {
            $sha = $tokens[$i]
            $body = $tokens[$i + 1]

            # If this commit has a Production Release tag and we haven't cut off yet,
            # skip messages for this commit AND all older ones.
            if (-not $stopMessages -and $tagMap.ContainsKey($sha)) {
                if ($tagMap[$sha] | Where-Object { $_.IsProduction() }) {
                    $stopMessages = $true
                    continue  # do not process messages for this commit
                }
            }

            # --- path filtering: skip commits that don't touch include paths or that match exclude paths
            $files = git diff-tree --no-commit-id --name-only -r $sha | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }

            if ($includePatterns.Count -gt 0) {
                $matchedInclude = $false
                foreach ($f in $files) {
                    foreach ($p in $includePatterns) {
                        if ($f -like "$p*" -or $f -like "*$p*") { $matchedInclude = $true; break }
                    }
                    if ($matchedInclude) { break }
                }
                if (-not $matchedInclude) { continue }
            }

            if ($excludePatterns.Count -gt 0) {
                $matchedExclude = $false
                foreach ($f in $files) {
                    foreach ($p in $excludePatterns) {
                        if ($f -like "$p*" -or $f -like "*$p*") { $matchedExclude = $true; break }
                    }
                    if ($matchedExclude) { break }
                }
                if ($matchedExclude) { continue }
            }
            # --- end path filtering

            if (-not $stopMessages) {
                $msgs = [QuickVersionMessage]::Parse($body)
                foreach ($m in $msgs) { $messages.Add($m) | Out-Null }
            }
        }

        # ---------------------------------------------------------------------------------------------
        # Determine lastVersion (highest Production Release) and nexts
        # ---------------------------------------------------------------------------------------------
        $prodVersions = $allVersions | Where-Object { $_.IsProduction() }

        if ($prodVersions.Count -gt 0) {
            $lastVersion = $prodVersions | Sort-Object `
                @{ e = { $_.Major }; Descending = $true }, `
                @{ e = { $_.Minor }; Descending = $true }, `
                @{ e = { $_.Patch }; Descending = $true }, `
                @{ e = { $_.Build }; Descending = $true } `
                | Select-Object -First 1
        } else {
            # No production version found; treat as 0.0.0.0 baseline
            $lastVersion = [QuickVersion]::new(0,0,0,0,"",0,"")
        }

        
        # Force min version constriants to 1.0
        if($lastVersion.Major -eq 0 -and $lastVersion.Minor -eq 0) {
          $nextVersionMajor = [QuickVersion]::new(0,1,0,0,"",0,"")
          $nextVersionMinor = [QuickVersion]::new(0,1,0,0,"",0,"")
          $nextVersionPatch = [QuickVersion]::new(0,1,0,0,"",0,"")
          $nextVersionBuild = [QuickVersion]::new(0,1,0,0,"",0,"")
        }
        else {
          $nextVersionMajor = [QuickVersion]::new($baseVersion.Major + 1, 0, 0, 0, "", 0, "")
          $nextVersionMinor = [QuickVersion]::new($baseVersion.Major, $baseVersion.Minor + 1, 0, 0, "", 0, "")
          $nextVersionPatch = [QuickVersion]::new($baseVersion.Major, $baseVersion.Minor, $baseVersion.Patch + 1, 0, "", 0, "")
          $nextVersionBuild = [QuickVersion]::new($baseVersion.Major, $baseVersion.Minor, $baseVersion.Patch, $baseVersion.Build + 1, "", 0, "")
        }


        # Determine bump from conventional commit messages (breaking -> major, feat -> minor, fix -> patch, any other commit -> build)
        $isBreaking = ($messages | Where-Object { $_.Message -match 'BREAKING CHANGE' -or $_.Message -match 'BREAKING-CHANGE' -or ($_.Type -match '.*!$') }).Count
        $hasFeat = ($messages | Where-Object { $_.Type -ieq 'feat' }).Count
        $hasFix = ($messages | Where-Object { $_.Type -ieq 'fix' }).Count

        if ($isBreaking -gt 0) { $bump = 'major' }
        elseif ($hasFeat -gt 0) { $bump = 'minor' }
        elseif ($hasFix -gt 0) { $bump = 'patch' }
        elseif ($messages.Count -gt 0) { $bump = 'build' }
        else { $bump = 'none' }

        # Inputs from composite action become environment variables INPUT_<NAME> (hyphens -> underscores)
        $inputLabel = $env:INPUT_VERSION_LABEL
        $inputMetadata = $env:INPUT_BUILD_METADATA

        switch ($bump) {
            'major' { $candidate = $nextVersionMajor }
            'minor' { $candidate = $nextVersionMinor }
            'patch' { $candidate = $nextVersionPatch }
            'build' { $candidate = $nextVersionBuild }
            default { $candidate = $nextVersionBuild }
        }

        if ([string]::IsNullOrWhiteSpace($inputLabel)) {
            # Production next version
            $nextVersion = $candidate
        } else {
            # Pre-release: base on candidate and use commits-since-last-production as ReleaseBuild (>=1)
            $releaseBuild = if ($messages.Count -gt 0) { $messages.Count } else { 1 }
            $nextVersion = [QuickVersion]::new($candidate.Major, $candidate.Minor, $candidate.Patch, $candidate.Build, $inputLabel, $releaseBuild, $inputMetadata)
        }


        # ---------------------------------------------------------------------------------------------
        # Display (or set outputs in a composite action)
        # ---------------------------------------------------------------------------------------------
        Write-Host "Production versions found: $($prodVersions.Count)"
        Write-Host "Last production version : $($lastVersion.ToString())"
        Write-Host "Next major              : $($nextVersionMajor.ToString())"
        Write-Host "Next minor              : $($nextVersionMinor.ToString())"
        Write-Host "Next patch              : $($nextVersionPatch.ToString())"
        Write-Host "Next build              : $($nextVersionBuild.ToString())"
        Write-Host ""
        Write-Host "Conventional commit messages collected (newest → oldest, until latest prod tag): $($messages.Count)"
        $messages | ForEach-Object { Write-Host (" - {0}: {1}" -f $_.Type, $_.Message) }

        # If running inside GitHub Actions and you want outputs:
        # If running inside GitHub Actions and you want outputs:
        if ($env:GITHUB_OUTPUT) {
            # Serialize complex types as JSON
            $jsonMessages = $messages | ConvertTo-Json -Depth 6
            $jsonProdVers = $prodVersions | ConvertTo-Json -Depth 6

            Add-Content -Path $env:GITHUB_OUTPUT -Value ("lastVersion=$($lastVersion.ToString())")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("nextVersionMajor=$($nextVersionMajor.ToString())")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("nextVersionMinor=$($nextVersionMinor.ToString())")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("nextVersionPatch=$($nextVersionPatch.ToString())")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("nextVersionBuild=$($nextVersionBuild.ToString())")

            # Primary computed next version outputs
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("major=$($nextVersion.Major)")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("minor=$($nextVersion.Minor)")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("patch=$($nextVersion.Patch)")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("build=$($nextVersion.Build)")
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("version=$($nextVersion.ToString())")

            $labelStr = ""
            if (-not [string]::IsNullOrWhiteSpace($nextVersion.ReleaseLabel)) {
                if ([string]::IsNullOrWhiteSpace($nextVersion.ReleaseNote)) {
                    $labelStr = "$($nextVersion.ReleaseLabel).$($nextVersion.ReleaseBuild)"
                } else {
                    $labelStr = "$($nextVersion.ReleaseLabel).$($nextVersion.ReleaseBuild)+$($nextVersion.ReleaseNote)"
                }
            }
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("label=$labelStr")

            $infoVersion = $nextVersion.ToString()
            if (-not [string]::IsNullOrWhiteSpace($labelStr)) { $infoVersion = "$infoVersion-$labelStr" }
            Add-Content -Path $env:GITHUB_OUTPUT -Value ("infoVersion=$infoVersion")

            # Multi-line values must use the EOF delimiter
            Add-Content -Path $env:GITHUB_OUTPUT -Value "messagesJson<<EOF"
            Add-Content -Path $env:GITHUB_OUTPUT -Value $jsonMessages
            Add-Content -Path $env:GITHUB_OUTPUT -Value "EOF"

            Add-Content -Path $env:GITHUB_OUTPUT -Value "productionVersionsJson<<EOF"
            Add-Content -Path $env:GITHUB_OUTPUT -Value $jsonProdVers
            Add-Content -Path $env:GITHUB_OUTPUT -Value "EOF"
        }
